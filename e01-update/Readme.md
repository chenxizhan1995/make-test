
逻辑上,按如下步骤判断给定规则的target是否需要更新:
1. target 是 phony target 或者 target 对应的文件不存在，则无条件执行，继续判断
2. 否则(此时 target 不是伪目标，且文件 target 存在),
    如果 target 没有任何依赖，则 target 不需要更新。判断结束。
3. 否则(target 存在依赖)。设 p 是 target 的一个依赖：
   - 如果没有任何与 p 匹配的规则
     - 若不存在文件 p，则报错退出；
     - 若文件 p 存在，则按照 target 和 p 的时间戳判断是否更新 target。
   - 如果存在与 p 匹配的规则，转到步骤 4
4. 分情况讨论：
   - 如果 p 是伪目标，那么执行 target
   - 如果 p 不是伪目标且不需要执行p，那么一定存在文件 p，于是：当 p 比 t 新时需要执行 t，当 p 不比 t 新时，不需要执行 t
   - 如果 p 不是伪目标且需要执行p，分情况
     - p 执行后仍不存在文件 p，则 p 是事实上的伪目标，执行 target
     - p 执行后存在文件 p，则仅当 p 比 target 新时，执行 target。
  ps：p 是否需要执行，使用规则 1，2，3，4 递归判断。
ps：当 target 有多个依赖时，则
- 只要有一个依赖p判定需要执行 target，就执行 target，
- 仅当所有依赖p的判定结果都是“不需要执行target”的时候才不执行target。

一句话：只要有依赖且的文件实际存在时，则直接看文件的新旧关系。除非依赖p或目标t本身有一个是伪目标。
“t 依赖 p，则只要规则 p 存在且 p 执行过，t 就一定执行”。这种说法是不对的。要看 t 和 p 的新旧程度。

根据以上总结，制作对应的流程图，对流程图的中每个分支设置适当的实验场景，进行验证。
